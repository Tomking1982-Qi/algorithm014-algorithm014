# 解题步骤 (覃超老师)
1、Clarificaiton（了解清楚题目意思及必要的交流）理解题意，包括数据范围

2、Possible solution -> Optimal (Time & Space) 思考可能的解法

3、Code （compare(time/space) 对比每种解法的时间空间复杂度， 写出最佳解答）

4、Test (多case 测试)

# 五毒神掌
第一遍：5～10分钟 读题+思考，如果没思路直接看题解（多解法），比较解法优劣 背诵并默写好的解法

第二遍：马上自己写，提交，多种解法（特别要查看LeetCode国际站最优解）比较体会，再优化

第三遍：一天后，再重复做题，加强不同解法的熟练程度与专项练习

第四遍：一周后，再重复练习相同题目（自己容易记住的解法，最好是最优解）

第五遍：面试前一周恢复性训练

Note: 思维导图(利用碎片时间多多学习，加强记忆与理解（由多到少，有厚到薄，有全部题解到关键代码)




## 基础
    两数之和（简单）
    有效的括号（简单）
    字符串解码（中等）
    LRU 缓存机制（困难）
    实现 Trie（前缀树）（中等）
    添加与搜索单词 - 数据结构设计（中等）
    单词搜索 II （困难）
    找不同（简单）
    单词规律（简单）
    字符串中的第一个唯一字符（简单）
    无重复字符的最长子串（中等）
    最小覆盖子串（困难）
    合并两个有序链表（简单）
    环形链表（简单）
    环形链表 II （中等）
    反转链表（简单）
    反转链表 II （中等）
    旋转链表（中等）
## 排序链表
    链表中倒数第 k 个节点
    两两交换链表中的节点（中等）
    按奇偶排序数组（简单）
    按奇偶排序数组 II （简单）
    有序数组的平方（简单）
    山脉数组的峰顶索引（简单）
    搜索旋转排序数组（困难）
    搜索旋转排序数组 II （中等）
    寻找旋转排序数组中的最小值（中等）
    寻找旋转排序数组中的最小值 II （困难）
    搜索二维矩阵（中等）
    等式方程的可满足性（中等）
    朋友圈（中等）
    账户合并（中等）
深度优先搜索
    二叉树的最大深度（简单）
    路径总和（简单）
    路径总和 II （中等）
    被围绕的区域（中等）
    岛屿数量（中等）
    岛屿的最大面积（中等）
    在二叉树中分配硬币（中等）
## 回溯
    括号生成（中等）
    N 皇后（困难）
    N 皇后 II （困难）
    解数独 （中等）
    不同路径 III （困难）
    单词搜索（中等）
## 分治
    搜索二维矩阵 II （中等）
    合并 K 个排序链表（中等）
    为运算表达式设计优先级（中等）
    给表达式添加运算符（困难）
    数组中的第 K 个最大元素（中等）
    最接近原点的 K 个点（中等）
    鸡蛋掉落（困难）
## 动态规划
    使用最小花费爬楼梯（简单）
    爬楼梯（简单）
    不同路径（简单）
    最小路径和 （中等）
    最大子序和 （简单）
    乘积最大子数组（中等）
    买卖股票的最佳时机（简单）
    买卖股票的最佳时机 II （简单）
    买卖股票的最佳时机 III （困难）
    买卖股票的最佳时机 IV （困难）
    最佳买卖股票时机含冷冻期（中等）
    买卖股票的最佳时机含手续费（中等）
    零钱兑换 （中等）
    零钱兑换 II （中等）
    编辑距离（困难）
    不同的子序列（困难）
    柱状图中最大的矩形（困难）
    最大矩形（困难）
    最大正方形（中等）
    最低票价（中等）
    区域和检索 - 数组不可变（简单）
    二维区域和检索 - 矩阵不可变（中等）
    最长上升子序列 （中等）
    鸡蛋掉落（困难）
    
 
## 以下为优秀同学的整理： 
1、做题习惯：

		(1) 不要死磕、敢于放手、敢于死记硬背代码
		
		(2) 要学习高手的优秀代码
		
		(3) 最佳方式：5分钟想不出来，直接看题解，然后学习理解，多做几遍
		
		(4) 每个题不要只做一遍，要多做几遍
		
2、学习方法：

		(1) 改变自己的学习习惯：不要死磕
		
		(2) 五毒神掌，过遍数
		
		(3) 学习其他人的代码和思路
		
		(4) 最大的误区：LeetCode的题只做一遍

3、精通一个领域：

		(1) 切碎一个知识点
		
		(2) 刻意练习
		
		(3) 反馈
		
4、数据结构：

		(1) 一维：数组、链表、栈、队列、双端队列、集合、映射
		
		(2) 二维：树、图、二叉搜索树、堆、并查集、字典树
		
		(3) 特殊：位运算、布隆过滤器、LRU Cache
		
5、算法：
	
		(1) If-else, switch --> 分支
		
		(2) for, while loop --> 迭代

		(3) 递归、分治、回溯
		
		(4) 搜索：深度优先搜索、广度优先搜索
		
		(5) 动态规划
		
		(6) 二分查找
		
		(7) 贪心
		
		(8) 数学、几何
		
6、基本功是区别业余和职业选手的根本

7、刻意练习 -- 过遍数、练习缺陷、弱点地方

8、反馈：

		(1) 即时反馈
		
		(2) 主动性反馈：高手代码、直播
		
		(3) 被动式反馈：code review
		
9、五步刷题法(五毒神掌)：

		(1) 第一遍：5分钟读题加思考、直接看解法、背诵/默写好的解法
		
		(2) 第二遍：马上自己写一遍、多种解法比较、体会-->优化
		
		(3) 第三遍：过了一天后，重复做题；专项练习
		
		(4) 第四遍：过一周后，反复回来练习相同题目
		
		(5) 第五遍：面试前一周恢复性训练
		
10、做算法题的最大误区：只做一遍

11、跳表：只能用于元素有序的情况。在原始链表的基础上，添加多级索引。

12、在跳表中查询任意数据的时间复杂度为O(logn), 空间复杂度O(n)

13、跳表：升维思想 + 空间换时间

14、题目练习步骤：

		(1) 5 - 10分钟：读题和思考
		
		(2) 有思路：自己开始做和写代码; 否则，马上看题解
		
		(3) 默写背诵、熟练
		
		(4) 不参考答案，自己独立完成
	
15、栈：先入后出，添加/删除复杂度为O(1)

16、队列：先入先出，添加/删除时间复杂度为O(1)

17、优先队列的实现机制：堆、二叉搜索树、树堆(Treap)

18、链表是特殊化的树，树是特殊化的图

19、二叉树的遍历：

		(1) 前序：根-左-右
		
		(2) 中序：左-根-右

		(3) 后序：左-右-根
		
20、树的根节点只有一个：有一个特定的结点被称为根结点或树根。

21、二叉搜索树的中序遍历(左-根-右)是一个升序序列。

22、树的面试题解法一般都是递归(自重复性)。

23、递归 -- 循环：通过函数体来进行循环

24、递归的思维要点：

		(1) 不要人肉进行递归
		
		(2) 找到最近最简方法，将其拆解可重复解决的问题(重复子问题)
		
		(3) 数学归纳法思维
		
25、Heap: 可以迅速找到一堆数中的最大或者最小值的数据结构。

26、堆：通过完全二叉树来实现

27、二叉树一般通过“数组”来实现。

		(1) 索引为i的左孩子的索引是(2*i+1)
		
		(2) 索引为i的右孩子的索引是(2*i+2)
		
		(3) 索引为i的父节点的索引是floor((i-1)/2)
		
28、插入操作：

		(1) 新元素一律插入到堆的尾部
		
		(2) 依次向上调整整个堆的结构(一直到根即可)
	
29、删除堆顶操作：

		(1) 将堆尾元素替换到顶部(即对顶被替代删除掉)
		
		(2) 依次从根部向上调整整个堆的结构(一直到堆尾即可)

30、分治：分解为子问题，然后合并。

31、回溯：回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。

32、回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况:

		(1) 找到一个可能存在的正确的答案
		
		(2) 在尝试了所有可能的分步方法后宣告该问题没有答案
		
		在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算
	
33、贪心算法是一种在每一步选择中都采取在当前状态下最好或最优(即最有利)的选择，从而希望导致结果是全局最好或最优的算法。

34、贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

35、一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。

36、问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。

37、贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

38、二分查找的前提：

		(1) 目标函数单调性(单调递增或者递减)
		
		(2) 存在上下界(bounded)
		
		(3) 能够通过索引访问(index accessible)
		
39、动态规划：分治 + 回溯 + 递归 + 动态规划 

40、寻找重复性 --> 计算机指令集

41、关键点：
	
		(1) 动态规划和递归或者分治没有根本上的区别(关键看有无最优的子结构)
		
		(2) 共性：找到重复子问题
		
		(3) 差异性：最优子结构、中途可以淘汰次优解

42、动态规划关键点：

		(1) 最优子结构：opt[n] = best_of(opt[n-1],opt[n-2],...)
		
		(2) 储存中间结构：opt[i]
		
		(3) 递推公式(美其名曰：状态转移方程或者D方程)
		
43、动态规划小结：

		(1) 打破自己的思维惯性，形成机器思维
		
		(2) 理解复杂逻辑的关键
		
		(3) 职业进阶的要点要领
		
44、字典树：即Trie数，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串(但不仅限于字符串)，所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。

45、基本性质：

		(1)节点本身不存在完整单词
		(2)从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串

		(3)每个结点的所有子结点路径代表的字符都不相同
		
46、Trie树的核心思想是空间换时间

47、利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的

48、高级搜索：剪枝、双向BFS、启发式搜索(A*)

49、红黑树是一种近似平衡的二叉搜索树，它能够确保任何一个结点的左右子树的高度差小于两倍。

50、红黑树满足以下条件：

		(1) 每个结点要么是红色，要么是黑色
		
		(2) 根节点是黑色
		
		(3) 每个叶节点是黑色的
		
		(4) 不能有相邻接的两个红色结点
		
		(5) 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点
		
51、指定位置的位运算：

		(1) 将x最右边的n位清零：x & (~0 << n)
		
		(2) 获取x的第n位值(0或者1): (x >> n) & 1
		
		(3) 获取x的第n位的幂值：x & (1 << n)
		
		(4) 仅将第n位置为1： x | (1 << n)
		
		(5) 仅将第n位置为0： x & (~(1 << n))

		(6) 将x最高位至第n位(含)清零：x & ((1 << n) - 1)

52、实战位运算要点:

		(1) 判断奇偶：
		
				x % 2 == 1 --> (x & 1) == 1
				x % 2 == 0 --> (x & 1) == 0

		(2) x >> 1 --> x / 2
		
		(3) x = x & (x - 1) : 清零最低位的1
		
		(4) x & -x ==> 得到最低位的1

		(5) x & ~x => 0
		
53、正数的二进制补码：就是原码

54、负数的二进制补码：将这个负整数的绝对值求反加1

55、布隆过滤器：一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。

56、布隆过滤器：

		(1) 优点：空间效率和查询时间都远远超过一般的算法
		
		(2) 缺点：有一定的误识别率和删除困难
		
57、LRU Cache： 哈希表 + 双向链表

		(1) 查询：O(1)
		
		(2) 修改、更新：O(1)

58、排序算法：

		(1) 交换排序：冒泡排序、快速排序
		
		(2) 插入排序：简单插入排序、希尔排序
		
		(3) 选择排序：简单选择排序、堆排序
		
		(4) 归并排序：二路归并排序、多路归并排序
		
		(5) 非比较类排序：计数排序、桶排序、基数排序
		
59、选择排序：每次选择最小值，然后放到待排序序列的起始位置

60、插入排序：从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

61、冒泡排序：嵌套循环，每次查看相邻的元素。如果逆序，则交换

62、快速排序：数组取标杆pivot，将小元素放在pivot的左边，大元素放在右边，然后依次对左边和右边的子数组继续快排；以达到整个序列有序

63、归并排序：

	(1) 把长度为n个输入序列分成两个长度为n/2的子序列
	
	(2) 对这两个子序列分别采用归并排序
	
	(3) 将两个排序好的子序列合并成一个最终的排序序列
	
64、归并和快排具有相似性：

	(1) 归并：先排序左右子数组，然后合并两个有序子数组
	
	(2) 快排：先调配出左右子数组，然后对于左右子数组进行排序

65、堆排序：

	(1) 数组元素依次建立小顶堆
	
	(2) 依次取堆顶元素，并删除
	
66、计数排序：计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转换为键存储在额外开辟的数组空间中；然后依次把计数大于1的填充回原数组。

67、桶排序：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序(有可能再使用别的排序算法或者是以递归方式继续使用桶排序进行排列)。

68、基数排序：按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。

69、字符串匹配算法：Rabin-Karp算法、KMP算法    
